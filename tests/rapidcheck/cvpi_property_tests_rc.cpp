#ifndef CVPI
extern "C" {
#include "cvpi.h"
#ifndef CVPI_EGL_SURFACE_FUNCTIONS
#include "cvpi_egl_surface_functions.h"
#endif
#include <getopt.h>
};
#endif
#include <rapidcheck.h>
#include <array>
#include <exception>
#include <opencv2/opencv.hpp>
#include <cstdlib>
#include <cstring>
#include <ostream>
#include <iostream>
#include <utility>
#include <cmath>
#include <random>
#include <chrono>
#include <regex>

bool PRINT_IMAGES = false;
bool PRINTED = false;
bool PRINT_DIMS = false;
bool BENCHMARK = false;
const std::string CVPI_TEST = "cvpi_";
const std::string CPU_TEST = "cpu_";
static int TIME_IT_ITTERATIONS = 10;

namespace time_it {
  std::chrono::high_resolution_clock::time_point t1;
  std::chrono::high_resolution_clock::time_point t2;
  int itter;
  std::chrono::duration<double> time_span;
}

void reset(void) {
  PRINTED = false;
}

#define TIME_IT(name, width, height, itterations, code) do {if(BENCHMARK){ \
    time_it::t1 = std::chrono::high_resolution_clock::now();				\
    time_it::itter = itterations;					\
    do{code; --time_it::itter;} while (time_it::itter != 0);		\
    time_it::t2 = std::chrono::high_resolution_clock::now();		\
    time_it::time_span = std::chrono::duration_cast<std::chrono::duration<double>>(time_it::t2 - time_it::t1); \
    std::cout << name << " ";						\
    std::cout << "start: " << time_it::t1.time_since_epoch().count() << " "; \
    std::cout << "end: " << time_it::t2.time_since_epoch().count() << " "; \
    std::cout << "width: " << width << " ";				\
    std::cout << "height: " << height << " ";				\
    std::cout << time_it::time_span.count()/((double)itterations);	\
    std::cout << "s" << std::endl;					\
  } else {code;}} while(false)

// maximum dimensions for 'small' images generated directly by
// rapidcheck. Larger images are generated by a random number generator seeded
// by rapidcheck.
const int MAX_WIDTH = 500;
const int MAX_HEIGHT = 500;

// EGL_CONFIG_MAX_WIDTH * EGL_CONFIG_MAX_HEIGHT;
const int MAX_SIZE = MAX_WIDTH * MAX_HEIGHT;

struct Dimensions {
  uint32_t width;
  uint32_t height;
};

// small dimensions
struct SDimensions : public Dimensions {};

// big dimensions
struct BDimensions : public Dimensions {};

// half width dimensions
struct HDimensions : public Dimensions {};

namespace rc {
  template<>
  struct Arbitrary<SDimensions> {
    static Gen<SDimensions> arbitrary() {
      return gen::build<SDimensions>(gen::set(&SDimensions::width, gen::inRange(1, MAX_WIDTH + 1)),
				     gen::set(&SDimensions::height, gen::inRange(1, MAX_HEIGHT + 1)));
    };
  };
  template<>
  struct Arbitrary<BDimensions> {
    static Gen<BDimensions> arbitrary() {
      return gen::build<BDimensions>(gen::set(&BDimensions::width, gen::inRange(MAX_WIDTH + 1, EGL_CONFIG_MAX_WIDTH + 1)),
				     gen::set(&BDimensions::height, gen::inRange(MAX_HEIGHT + 1, EGL_CONFIG_MAX_HEIGHT + 1)));
    };
  };
  template<>
  struct Arbitrary<HDimensions> {
    static Gen<HDimensions> arbitrary() {
      return gen::build<HDimensions>(gen::set(&HDimensions::width, gen::inRange(1, EGL_CONFIG_MAX_WIDTH/2 + 1)),
				     gen::set(&HDimensions::height, gen::inRange(1, EGL_CONFIG_MAX_HEIGHT + 1)));
    };
  };
};

class EGL_session {
public:
  cvpi_egl_settings settings = NULL;
  cvpi_egl_instance instance = NULL;
  EGL_session() {
      settings = cvpi_egl_settings_create();
      if(settings == NULL) {
	throw std::runtime_error("cvpi_egl_settings_create failed.");
      }
      settings->surface_pixmap_create_function = cvpi_egl_surface_pixmap_native_creator;
      settings->surface_pixmap_destroy_function = cvpi_egl_surface_pixmap_native_destroyer;
      settings->renderable_api = cvpi_egl_renderable_api_openvg;
      settings->current_surface_type = cvpi_egl_surface_type_pixmap;

      CVPI_BOOL good = CVPI_TRUE;
      good &=
	CVPI_TRUE_TEST(cvpi_egl_settings_conformant(settings, cvpi_egl_conformant_bit_openvg, cvpi_egl_settings_add));
      good &=
	CVPI_TRUE_TEST(cvpi_egl_settings_renderable_type(settings, cvpi_egl_renderable_bits_openvg, cvpi_egl_settings_add));
#if HAVE_BCM_HOST == 1
      good &=
	CVPI_TRUE_TEST(cvpi_egl_settings_pixel_format_brcm(settings, cvpi_egl_pixel_format_vg_image_brcm, cvpi_egl_settings_add));
#endif
#if HAVE_BCM_HOST == 1
      good &=
	CVPI_TRUE_TEST(cvpi_egl_settings_pixel_format_brcm(settings,cvpi_egl_pixel_format_render_vg_brcm, cvpi_egl_settings_add));
#endif
#if HAVE_BCM_HOST == 1
      good &=
	CVPI_TRUE_TEST(cvpi_egl_settings_pixel_format_brcm(settings,cvpi_egl_pixel_format_usage_mask_brcm, cvpi_egl_settings_add));
#endif
#if HAVE_BCM_HOST == 1
      good &=
	CVPI_TRUE_TEST(cvpi_egl_settings_pixel_format_brcm(settings,cvpi_egl_pixel_format_texture_mask_brcm, cvpi_egl_settings_add));
#endif
#if HAVE_BCM_HOST == 1
      good &=
	CVPI_TRUE_TEST(cvpi_egl_settings_pixel_format_brcm(settings,cvpi_egl_pixel_format_render_mask_brcm, cvpi_egl_settings_add));
#endif

      good &=
	CVPI_TRUE_TEST(cvpi_egl_settings_surface_type(settings,cvpi_egl_surface_bits_colorspace, cvpi_egl_settings_add));
      good &=
	CVPI_TRUE_TEST(cvpi_egl_settings_surface_type(settings,cvpi_egl_surface_bits_alpha, cvpi_egl_settings_add));
      good &=
	CVPI_TRUE_TEST(cvpi_egl_settings_surface_type(settings,cvpi_egl_surface_bits_multisample, cvpi_egl_settings_add));
      good &=
	CVPI_TRUE_TEST(cvpi_egl_settings_surface_type(settings,cvpi_egl_surface_bits_swap, cvpi_egl_settings_add));

      good &=
	CVPI_TRUE_TEST(cvpi_egl_settings_buffer_size(settings, 32));

      good &=
	CVPI_TRUE_TEST(cvpi_egl_settings_surface_type(settings, cvpi_egl_surface_bits_pixmap, cvpi_egl_settings_add));
      good &=
	CVPI_TRUE_TEST(cvpi_egl_settings_surface_type(settings, cvpi_egl_surface_bits_pbuffer, cvpi_egl_settings_remove));
      good &=
	CVPI_TRUE_TEST(cvpi_egl_settings_surface_type(settings, cvpi_egl_surface_bits_window, cvpi_egl_settings_remove));

      if(!good) {
	if(settings != NULL) {
	  free(settings);
	  settings = NULL;
	}
	throw std::runtime_error("Invalid EGL settings.");
      }
      instance = cvpi_egl_instance_setup(settings);
      if(instance == NULL) {
	free(settings);
	settings = NULL;
	throw std::runtime_error("cvpi_egl_instance creation failed.");
      }
  };

  ~EGL_session() {
    cvpi_egl_instance_takedown(instance);
    if(settings != NULL) {
      free(settings);
      settings = NULL;
    }
  };
};

bool compare_mats(cv::Mat &cvpi_mat, cv::Mat &ocv_mat) {
  bool success = false;
  if(cvpi_mat.rows == ocv_mat.rows) {
    if(cvpi_mat.cols == ocv_mat.cols) {
      success = std::equal(ocv_mat.begin<uint32_t>(), ocv_mat.end<uint32_t>(), cvpi_mat.begin<uint32_t>());
      if(!success  && PRINT_DIMS) {
      	std::cerr << "height: " << cvpi_mat.rows << " width: " << cvpi_mat.cols << std::endl;
      }
    } else {
      success = false;
      if(PRINT_DIMS) {
	std::cerr << "heights differ: " << cvpi_mat.cols << " " << ocv_mat.cols << std::endl;
      }
    }
  } else {
    success = false;
    if(PRINT_DIMS) {
      std::cerr << "widths differ: " << cvpi_mat.rows << " " << ocv_mat.rows << std::endl;
    }
  }
  return success;
}

bool add_image_test_common(std::string name, uint32_t *image_data_1, uint32_t *image_data_2, Dimensions &dimensions) {
  uint32_t image_pix_cnt = dimensions.width * dimensions.height;
  EGL_session *session = NULL;
  try {
    session = new EGL_session();
  } catch(std::exception& e) {
    RC_FAIL(e.what());
  }

  uint32_t *cvpi_out = new uint32_t[image_pix_cnt];
  cv::Mat cv_out, cv_image_1, cv_image_2, cvpi_sum_mat;
  VGImage image1, image2, cvpi_sum;

  image1 = vgCreateImage(CVPI_COLOR_SPACE, dimensions.width, dimensions.height,VG_IMAGE_QUALITY_NONANTIALIASED);
  image2 = vgCreateImage(CVPI_COLOR_SPACE, dimensions.width, dimensions.height,VG_IMAGE_QUALITY_NONANTIALIASED);
  vgFinish();
  vgImageSubData(image1, image_data_1, dimensions.width*CVPI_PIXEL_BYTES, CVPI_COLOR_SPACE, 0, 0, dimensions.width, dimensions.height);
  vgImageSubData(image2, image_data_2, dimensions.width*CVPI_PIXEL_BYTES, CVPI_COLOR_SPACE, 0, 0, dimensions.width, dimensions.height);
  vgFinish();
  TIME_IT(CVPI_TEST + name, dimensions.width, dimensions.height, TIME_IT_ITTERATIONS,
	  cvpi_sum = cvpi_image_add(image1, image2, 1, 1, 1, 0);
	  vgFinish();
	  vgGetImageSubData(cvpi_sum, cvpi_out, CVPI_PIXEL_BYTES*dimensions.width, CVPI_COLOR_SPACE, 0, 0, dimensions.width, dimensions.height);
	  vgFinish();
	  vgDestroyImage(cvpi_sum);
	  );
  vgDestroyImage(image1);
  vgDestroyImage(image2);

  // OpenCV calculation
  cv_image_1 = cv::Mat(dimensions.height, dimensions.width, CV_8UC4, image_data_1);
  cv_image_2 = cv::Mat(dimensions.height, dimensions.width, CV_8UC4, image_data_2);

  TIME_IT(CPU_TEST + name, dimensions.width, dimensions.height, TIME_IT_ITTERATIONS, cv::add(cv_image_1, cv_image_2, cv_out));

  cvpi_sum_mat = cv::Mat(dimensions.height, dimensions.width, CV_8UC4, cvpi_out);

  bool success = compare_mats(cvpi_sum_mat, cv_out);
  if(!success && PRINT_IMAGES && !PRINTED) {
    std::cerr << std::endl << cvpi_sum_mat << std::endl << std::endl;
    std::cerr << std::endl << cv_image_1 << std::endl << std::endl;
    std::cerr << std::endl << cv_image_2 << std::endl << std::endl;
    PRINTED = true;
  }

  if(session != NULL) {
    delete session;
  }

  delete cvpi_out;

  return success;
}

int main(int argc, char **argv) {
  // Options:
  // -t [number] : get execution times.  Repeat profiled function <number> times, default 10.
  // -d : print dimensions of images used in failed tests
  // -p : print images for the first failed test

  int opt;
  int argc_i = 1;
  int test_num = 0;
    
  while((opt = getopt(argc, argv, "dpt::")) != -1) {
    argc_i++;
    switch(opt) {
    case 'd':
      PRINT_DIMS = true;
      break;
    case 'p':
      PRINT_IMAGES = true;
      break;
    case 't':
      BENCHMARK = true;
      if(optarg) {
	if(std::regex_match(optarg, std::regex("^\\d+$"))) {
	  int times = atoi(optarg);
	  if(times > 0) {
	    TIME_IT_ITTERATIONS = times;
	  }
	} else {
	  std::cerr << "-t option cannot be followed by a non-numeric value." << std::endl;
	  return 1;
	}
      }
      break;
    }
  }
  do {
    if(optind < argc) {
      std::stringstream ss(argv[optind]);
      if((ss >> test_num).fail()) {
	std::cerr << "Failed to select a check to run." << std::endl;
	return 1;
      }
    }
    if(test_num == 0 || test_num == 1) {
      rc::check("add images large const", [](const BDimensions &dimensions, const unsigned int &val_1, const unsigned int &val_2) {
	  uint32_t image_pix_cnt = dimensions.width * dimensions.height;
	  uint32_t* image_data_1 = new uint32_t[image_pix_cnt];
	  uint32_t* image_data_2 = new uint32_t[image_pix_cnt];
	  std::fill_n(image_data_1, image_pix_cnt, val_1);
	  std::fill_n(image_data_2, image_pix_cnt, val_2);

	  bool success = add_image_test_common("add_images_large_const", image_data_1, image_data_2, (Dimensions&)dimensions);

	  delete image_data_1;
	  delete image_data_2;

	  RC_ASSERT(success);
	});
      reset();
    }
    if(test_num == 0 || test_num == 2) {
      rc::check("add images large const small", [](const BDimensions &dimensions, const unsigned char &val_1, const unsigned char &val_2) {
	  uint32_t image_pix_cnt = dimensions.width * dimensions.height;
	  uint32_t* image_data_1 = new uint32_t[image_pix_cnt];
	  uint32_t* image_data_2 = new uint32_t[image_pix_cnt];
	  cvpi_pixel pix_img_1;
	  cvpi_pixel pix_img_2;
	  pix_img_1.channel[0] = val_1;
	  pix_img_1.channel[1] = val_1;
	  pix_img_1.channel[2] = val_1;
	  pix_img_1.channel[3] = val_1;
	  pix_img_2.channel[0] = val_2;
	  pix_img_2.channel[1] = val_2;
	  pix_img_2.channel[2] = val_2;
	  pix_img_2.channel[3] = val_2;
	  std::fill_n(image_data_1, image_pix_cnt, pix_img_1.all);
	  std::fill_n(image_data_2, image_pix_cnt, pix_img_2.all);

	  bool success = add_image_test_common("add_images_large_const_small", image_data_1, image_data_2, (Dimensions&)dimensions);

	  delete image_data_1;
	  delete image_data_2;

	  RC_ASSERT(success);
	});
      reset();
    }
    if(test_num == 0 || test_num == 3) {
      rc::check("add images large random", [](const BDimensions &dimensions, const unsigned int &seed_1, const unsigned int &seed_2) {
	  uint32_t image_pix_cnt = dimensions.width * dimensions.height;
	  uint32_t* image_data_1 = new uint32_t[image_pix_cnt];
	  uint32_t* image_data_2 = new uint32_t[image_pix_cnt];

	  std::mt19937 generator_1(seed_1);
	  std::mt19937 generator_2(seed_2);
	  std::uniform_int_distribution<uint32_t> distribution(0,UINT32_MAX);
	  for(uint32_t i = 0; i < image_pix_cnt; ++i) {
	    image_data_1[i] = distribution(generator_1);
	    image_data_2[i] = distribution(generator_2);
	  }

	  bool success = add_image_test_common("add_images_large_random", image_data_1, image_data_2, (Dimensions&)dimensions);

	  delete image_data_1;
	  delete image_data_2;

	  RC_ASSERT(success);
	});
      reset();
    }
    if(test_num == 0 || test_num == 4) {
      rc::check("add images small", [](const std::array<uint32_t, MAX_SIZE> &image_data_1,
				       const std::array<uint32_t, MAX_SIZE> &image_data_2,
				       const SDimensions &dimensions) {
		  uint32_t image_pix_cnt = dimensions.width * dimensions.height;
		  uint32_t* image_1 = new uint32_t[image_pix_cnt];
		  uint32_t* image_2 = new uint32_t[image_pix_cnt];
		  std::copy_n(image_data_1.begin(), image_pix_cnt, image_1);
		  std::copy_n(image_data_2.begin(), image_pix_cnt, image_2);
		  RC_ASSERT(add_image_test_common("add_images_small", image_1, image_2, (Dimensions&)dimensions));
		});
      reset();
    }
    if(test_num == 0 || test_num == 5) {
      rc::check("yuyv2yuva_alpha", [](const HDimensions &dimensions, const unsigned int &seed, const unsigned char &alpha) {
	  std::string name = "yuyv2yuva_alpha";
	  uint32_t yuyv_pix_cnt = dimensions.width * dimensions.height;
	  cvpi_pixel* yuyv_data = new cvpi_pixel[yuyv_pix_cnt];
	  cvpi_pixel* yuva_data_cpu = new cvpi_pixel[2*yuyv_pix_cnt];
	  cvpi_pixel* yuva_data_cvpi = new cvpi_pixel[2*yuyv_pix_cnt];
	  VGImage yuva_image;
	  std::mt19937 generator(seed);
	  std::uniform_int_distribution<uint32_t> distribution(0,UINT32_MAX);
	  for(uint32_t i = 0; i < yuyv_pix_cnt; ++i) {
	    (yuyv_data[i]).all = distribution(generator);
	  }
	  // generate output to test against
	  TIME_IT(CPU_TEST + name, dimensions.width, dimensions.height, TIME_IT_ITTERATIONS,
		  for(uint32_t i = 0; i < yuyv_pix_cnt; ++i) {
		    (yuva_data_cpu[2*i]).channel[0] = (yuyv_data[i]).channel[0]; // Yuyv -> Yuva1
                    (yuva_data_cpu[2*i]).channel[1] = (yuyv_data[i]).channel[1]; // yUyv -> yUva1
                    (yuva_data_cpu[2*i]).channel[2] = (yuyv_data[i]).channel[3]; // yuyV -> yuVa1
                    (yuva_data_cpu[2*i]).channel[3] = alpha;
		    (yuva_data_cpu[2*i+1]).channel[0] = (yuyv_data[i]).channel[2]; // yuYv -> Yuva2
                    (yuva_data_cpu[2*i+1]).channel[1] = (yuyv_data[i]).channel[1]; // yUyv -> yUva2
                    (yuva_data_cpu[2*i+1]).channel[2] = (yuyv_data[i]).channel[3]; // yuyV -> yuVa2
                    (yuva_data_cpu[2*i+1]).channel[3] = alpha;
		  });

	  // calculated by CVPI
	  EGL_session *session = NULL;
	  try {
	    session = new EGL_session();
	  } catch(std::exception& e) {
	    RC_FAIL(e.what());
	  }
	  VGImage yuyv_image = vgCreateImage(CVPI_COLOR_SPACE, dimensions.width, dimensions.height,VG_IMAGE_QUALITY_NONANTIALIASED);
	  vgImageSubData(yuyv_image, yuyv_data, dimensions.width*CVPI_PIXEL_BYTES, CVPI_COLOR_SPACE, 0, 0, dimensions.width, dimensions.height);
	  TIME_IT(CVPI_TEST + name, dimensions.width, dimensions.height, TIME_IT_ITTERATIONS,
		  yuva_image = cvpi_yuyv2yuva_alpha(yuyv_image, alpha);
		  vgFinish();
		  vgGetImageSubData(yuva_image, yuva_data_cvpi, CVPI_PIXEL_BYTES*dimensions.width*2, CVPI_COLOR_SPACE, 0, 0, dimensions.width*2, dimensions.height);
		  vgFinish();
		  vgDestroyImage(yuva_image););
	  vgDestroyImage(yuyv_image);
	  int cmp = memcmp(yuva_data_cvpi, yuva_data_cpu, CVPI_PIXEL_BYTES*yuyv_pix_cnt*2);
	  if(session != NULL) {
	    delete session;
	  }

	  if(cmp != 0) {
	    if(PRINT_DIMS) {
	      printf("dims: %d x %d\n", dimensions.width, dimensions.height);
	    }
	    if(PRINT_IMAGES  && !PRINTED) {
	      printf("CVPI\n%x\n\nCPU\n%x\nYUYV\n%x\nalpha:%d\n--------\n\n", yuva_data_cvpi[0], yuva_data_cpu[0], yuyv_data[0], alpha);
	      PRINTED = true;
	    }
	  }
	
	  delete yuyv_data;
	  delete yuva_data_cpu;
	  delete yuva_data_cvpi;
	
	  RC_ASSERT(cmp == 0);
	});
      reset();
    }
  } while(++optind < argc);
  return 0;
}
